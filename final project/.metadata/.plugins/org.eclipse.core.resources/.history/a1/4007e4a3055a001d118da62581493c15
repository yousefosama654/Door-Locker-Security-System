#include"buzzer.h"
#include"usart.h"
#include"util/delay.h"
#include"avr/interrupt.h"
#include"twi.h"
#include"external_eeprom.h"
#include"timer0.h"
#include"timer1.h"
#include"dcmotor.h"
#define OpenDoorTime 300
#define HoldDoorTime 60
#define CloseDoorTime 300
#define DangerTime 1200
uint8 CONTROL_ECU_Password_1[5];
uint8 CONTROL_ECU_Password_2[5];
uint8 flag;
uint16 eeprom_index;
uint8 errorTrial = 0;
volatile int TIMER1_g_ticks = 0;
void TASK_mainInit(void);
void TASK_createNewPass(void);
void TASK_saveNewPass(void);
void TASK_checkPass(void);
void TASK_rotateMotor(void);
void TASK_turnOnBuzzer(void);
void MotorCallback(void);
void BuzzerCallback(void);
int main() {
	TASK_mainInit();
	while (1) {
		TASK_createNewPass();
	}
}
void TASK_mainInit(void) {
	sei();
	USART_ConfigType USART_config = { DISABLED_PARITY, BIT_1_STOP_SELECT, 8,
			9600 };
	TWI_Config TWI_config = { TWI_F_CPU_CLOCK, 1, 2 };
	Timer0_Config Timer0_config = { TIMER0_FAST_PWM_MODE,
			TIMER0_NON_INVERTING_MODE, TIMER0_F_CPU_CLOCK_8 };
	TIMER1_setCallback(MotorCallback);
	Timer1_ConfigType Timer1_configuration =
			{ 0, 8000, F_CPU_1024, Compare_Mode };
	TIMER1_init_Compare(&Timer1_configuration);
	USART_init(&USART_config);
	TWI_init(&TWI_config);
	Timer0_init(&Timer0_config);
	DcMotor_Init();
	BUZZER_init();
}
void TASK_createNewPass(void) {
	for (int i = 0; i < 5; i++) {
		CONTROL_ECU_Password_1[i] = USART_recieveByte();
		_delay_ms(50);
	}
	for (int i = 0; i < 5; i++) {
		CONTROL_ECU_Password_2[i] = USART_recieveByte();
		_delay_ms(50);
	}
	flag = 1;
	for (int i = 0; i < 5; i++) {
		if (CONTROL_ECU_Password_1[i] != CONTROL_ECU_Password_2[i]) {
			flag = 0;
			break;
		}
	}
	USART_sendByte(flag);
	if (flag == 1) {
		TASK_saveNewPass();
	}
}
void TASK_saveNewPass(void) {
	eeprom_index = 0x0311;
	for (int i = 0; i < 5; i++) {
		uint8 key = CONTROL_ECU_Password_2[i];
		EEPROM_writeByte(eeprom_index, key);
		_delay_ms(10);
		eeprom_index++;
	}
	TASK_checkPass();
}
void TASK_checkPass(void) {
	uint8 CONTROL_ECU_Password[5];
	uint8 val;
	flag = 1;
	eeprom_index = 0x0311;
	for (int i = 0; i < 5; i++) {
		CONTROL_ECU_Password[i] = USART_recieveByte();
		_delay_ms(50);
	}
	for (int i = 0; i < 5; i++) {
		EEPROM_readByte(eeprom_index, &val);
		_delay_ms(10);
		eeprom_index++;
		if (val != CONTROL_ECU_Password[i]) {
			flag = 0;
			break;
		}
	}
	USART_sendByte(flag);
	if (flag == 1) {
		TASK_rotateMotor();
	} else if (flag == 0 && errorTrial < 2) {
		errorTrial++;
		TASK_checkPass();
	} else {
		TASK_turnOnBuzzer();
	}
}
void MotorCallback(void) {
	TIMER1_g_ticks++;
//	if (TIMER1_g_ticks == OpenDoorTime + HoldDoorTime + CloseDoorTime + 1) {
//		TIMER1_g_ticks = 0;
//		TIMER1_deinit();
//	}
}
void BuzzerCallback(void) {
	TIMER1_g_ticks++;
	if (TIMER1_g_ticks == DangerTime + 1) {
		TIMER1_g_ticks = 0;
		TIMER1_deinit();
	}
}
void TASK_turnOnBuzzer(void) {
	BUZZER_on();
	while (TIMER1_g_ticks < DangerTime)
		;
	BUZZER_off();
}
void TASK_rotateMotor(void) {
	DcMotor_Rotate(CW);
	while (TIMER1_g_ticks < OpenDoorTime)
		;
//	_delay_ms(3000);
	DcMotor_Rotate(STOP);
	while (TIMER1_g_ticks < OpenDoorTime + HoldDoorTime)
		;
	_delay_ms(3000);
	DcMotor_Rotate(ACW);
	_delay_ms(3000);
	while (TIMER1_g_ticks < OpenDoorTime + HoldDoorTime + CloseDoorTime)
		;
	DcMotor_Rotate(STOP);
}
//	uint8 val = 0;
//	EEPROM_writeByte(0x0311, 0x02);
//	_delay_ms(10);
//	EEPROM_readByte(0x0311, &val);
//	BUZZER_init();
//	Timer_Config Timer_config = { TIMER0_FAST_PWM_MODE,
//			TIMER0_NON_INVERTING_MODE, TIMER0_F_CPU_CLOCK_8 };
// it needs some edit
//	Timer0_init(&Timer_config);
//	DcMotor_Init();
//	while (1) {
//		key = USART_recieveByte();
//		if (key == 3) {
//			BUZZER_on();
//			_delay_ms(1000);
//			BUZZER_off();
//			_delay_ms(1000);
//		}
//	}
